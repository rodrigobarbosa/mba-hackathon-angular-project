/**
 * @license Angular v9.1.12
 * (c) 2010-2020 Google LLC. https://angular.io/
 * License: MIT
 */

import { Type } from '@angular/core';

declare let angular: {
    bootstrap: (e: Element, modules: (string | IInjectable)[], config?: IAngularBootstrapConfig) => IInjectorService;
    module: (prefix: string, dependencies?: string[]) => IModule;
    element: {
        (e: string | Element | Document | IAugmentedJQuery): IAugmentedJQuery;
        cleanData: (nodes: Node[] | NodeList) => void;
    };
    injector: (modules: Array<string | IInjectable>, strictDi?: boolean) => IInjectorService;
    version: {
        major: number;
    };
    resumeBootstrap: () => void;
    getTestability: (e: Element) => ITestabilityService;
};


/**
 * A helper function to use when unit testing AngularJS services that depend upon downgraded Angular
 * services.
 *
 * This function returns an AngularJS module that is configured to wire up the AngularJS and Angular
 * injectors without the need to actually bootstrap a hybrid application.
 * This makes it simpler and faster to unit test services.
 *
 * Use the returned AngularJS module in a call to
 * [`angular.mocks.module`](https://docs.angularjs.org/api/ngMock/function/angular.mock.module) to
 * include this module in the unit test injector.
 *
 * In the following code snippet, we are configuring the `$injector` with two modules:
 * The AngularJS `ng1AppModule`, which is the AngularJS part of our hybrid application and the
 * `Ng2AppModule`, which is the Angular part.
 *
 * <code-example path="upgrade/static/ts/full/module.spec.ts"
 * region="angularjs-setup"></code-example>
 *
 * Once this is done we can get hold of services via the AngularJS `$injector` as normal.
 * Services that are (or have dependencies on) a downgraded Angular service, will be instantiated as
 * needed by the Angular root `Injector`.
 *
 * In the following code snippet, `heroesService` is a downgraded Angular service that we are
 * accessing from AngularJS.
 *
 * <code-example path="upgrade/static/ts/full/module.spec.ts"
 * region="angularjs-spec"></code-example>
 *
 * <div class="alert is-important">
 *
 * This helper is for testing services not components.
 * For Component testing you must still bootstrap a hybrid app. See `UpgradeModule` or
 * `downgradeModule` for more information.
 *
 * </div>
 *
 * <div class="alert is-important">
 *
 * The resulting configuration does not wire up AngularJS digests to Zone hooks. It is the
 * responsibility of the test writer to call `$rootScope.$apply`, as necessary, to trigger
 * AngularJS handlers of async events from Angular.
 *
 * </div>
 *
 * <div class="alert is-important">
 *
 * The helper sets up global variables to hold the shared Angular and AngularJS injectors.
 *
 * * Only call this helper once per spec.
 * * Do not use `createAngularJSTestingModule` in the same spec as `createAngularTestingModule`.
 *
 * </div>
 *
 * Here is the example application and its unit tests that use `createAngularTestingModule`
 * and `createAngularJSTestingModule`.
 *
 * <code-tabs>
 *  <code-pane header="module.spec.ts" path="upgrade/static/ts/full/module.spec.ts"></code-pane>
 *  <code-pane header="module.ts" path="upgrade/static/ts/full/module.ts"></code-pane>
 * </code-tabs>
 *
 *
 * @param angularModules a collection of Angular modules to include in the configuration.
 *
 * @publicApi
 */
export declare function createAngularJSTestingModule(angularModules: any[]): string;

/**
 * A helper function to use when unit testing Angular services that depend upon upgraded AngularJS
 * services.
 *
 * This function returns an `NgModule` decorated class that is configured to wire up the Angular
 * and AngularJS injectors without the need to actually bootstrap a hybrid application.
 * This makes it simpler and faster to unit test services.
 *
 * Use the returned class as an "import" when configuring the `TestBed`.
 *
 * In the following code snippet, we are configuring the TestBed with two imports.
 * The `Ng2AppModule` is the Angular part of our hybrid application and the `ng1AppModule` is the
 * AngularJS part.
 *
 * <code-example path="upgrade/static/ts/full/module.spec.ts" region="angular-setup"></code-example>
 *
 * Once this is done we can get hold of services via the Angular `Injector` as normal.
 * Services that are (or have dependencies on) an upgraded AngularJS service, will be instantiated
 * as needed by the AngularJS `$injector`.
 *
 * In the following code snippet, `HeroesService` is an Angular service that depends upon an
 * AngularJS service, `titleCase`.
 *
 * <code-example path="upgrade/static/ts/full/module.spec.ts" region="angular-spec"></code-example>
 *
 * <div class="alert is-important">
 *
 * This helper is for testing services not Components.
 * For Component testing you must still bootstrap a hybrid app. See `UpgradeModule` or
 * `downgradeModule` for more information.
 *
 * </div>
 *
 * <div class="alert is-important">
 *
 * The resulting configuration does not wire up AngularJS digests to Zone hooks. It is the
 * responsibility of the test writer to call `$rootScope.$apply`, as necessary, to trigger
 * AngularJS handlers of async events from Angular.
 *
 * </div>
 *
 * <div class="alert is-important">
 *
 * The helper sets up global variables to hold the shared Angular and AngularJS injectors.
 *
 * * Only call this helper once per spec.
 * * Do not use `createAngularTestingModule` in the same spec as `createAngularJSTestingModule`.
 *
 * </div>
 *
 * Here is the example application and its unit tests that use `createAngularTestingModule`
 * and `createAngularJSTestingModule`.
 *
 * <code-tabs>
 *  <code-pane header="module.spec.ts" path="upgrade/static/ts/full/module.spec.ts"></code-pane>
 *  <code-pane header="module.ts" path="upgrade/static/ts/full/module.ts"></code-pane>
 * </code-tabs>
 *
 *
 * @param angularJSModules a collection of the names of AngularJS modules to include in the
 * configuration.
 * @param [strictDi] whether the AngularJS injector should have `strictDI` enabled.
 *
 * @publicApi
 */
export declare function createAngularTestingModule(angularJSModules: string[], strictDi?: boolean): Type<any>;

declare type DirectiveRequireProperty = SingleOrListOrMap<string>;

declare type DirectiveTranscludeProperty = boolean | 'element' | {
    [key: string]: string;
};

declare interface IAngularBootstrapConfig {
    strictDi?: boolean;
}

declare interface IAnnotatedFunction extends Function {
    $inject?: Function extends {
        $inject?: string[];
    } ? Ng1Token[] : ReadonlyArray<Ng1Token>;
}

declare type IAugmentedJQuery = Node[] & {
    on?: (name: string, fn: () => void) => void;
    data?: (name: string, value?: any) => any;
    text?: () => string;
    inheritedData?: (name: string, value?: any) => any;
    contents?: () => IAugmentedJQuery;
    parent?: () => IAugmentedJQuery;
    empty?: () => void;
    append?: (content: IAugmentedJQuery | string) => IAugmentedJQuery;
    controller?: (name: string) => any;
    isolateScope?: () => IScope;
    injector?: () => IInjectorService;
    triggerHandler?: (eventTypeOrObject: string | Event, extraParameters?: any[]) => IAugmentedJQuery;
    remove?: () => void;
    removeData?: () => void;
};

declare interface IComponent {
    bindings?: {
        [key: string]: string;
    };
    controller?: string | IInjectable;
    controllerAs?: string;
    require?: DirectiveRequireProperty;
    template?: string | Function;
    templateUrl?: string | Function;
    transclude?: DirectiveTranscludeProperty;
}

declare type IInjectable = (Ng1Token | Function)[] | IAnnotatedFunction;

declare interface IInjectorService {
    get(key: string): any;
    has(key: string): boolean;
}

declare interface IModule {
    name: string;
    requires: (string | IInjectable)[];
    config(fn: IInjectable): IModule;
    directive(selector: string, factory: IInjectable): IModule;
    component(selector: string, component: IComponent): IModule;
    controller(name: string, type: IInjectable): IModule;
    factory(key: Ng1Token, factoryFn: IInjectable): IModule;
    value(key: Ng1Token, value: any): IModule;
    constant(token: Ng1Token, value: any): IModule;
    run(a: IInjectable): IModule;
}

declare interface IRootScopeService {
    $new(isolate?: boolean): IScope;
    $id: string;
    $parent: IScope;
    $root: IScope;
    $watch(exp: Ng1Expression, fn?: (a1?: any, a2?: any) => void): Function;
    $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;
    $destroy(): any;
    $apply(exp?: Ng1Expression): any;
    $digest(): any;
    $evalAsync(exp: Ng1Expression, locals?: any): void;
    $on(event: string, fn?: (event?: any, ...args: any[]) => void): Function;
    $$childTail: IScope;
    $$childHead: IScope;
    $$nextSibling: IScope;
    [key: string]: any;
}

declare interface IScope extends IRootScopeService {
}

declare interface ITestabilityService {
    findBindings(element: Element, expression: string, opt_exactMatch?: boolean): Element[];
    findModels(element: Element, expression: string, opt_exactMatch?: boolean): Element[];
    getLocation(): string;
    setLocation(url: string): void;
    whenStable(callback: Function): void;
}

declare type Ng1Expression = string | Function;


declare type Ng1Token = string;

declare type SingleOrListOrMap<T> = T | T[] | {
    [key: string]: T;
};

export declare const ɵangular_packages_upgrade_static_testing_testing_a: typeof angular.module;

export declare const ɵangular_packages_upgrade_static_testing_testing_b = "$$angularUpgradeAppType";

export declare const enum ɵangular_packages_upgrade_static_testing_testing_c {
    None = 0,
    Dynamic = 1,
    Static = 2,
    Lite = 3
}

export declare const ɵangular_packages_upgrade_static_testing_testing_d = "$$angularInjector";

export { }

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdGluZy5kLnRzIiwic291cmNlcyI6WyJ0ZXN0aW5nLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjkuMS4xMlxuICogKGMpIDIwMTAtMjAyMCBHb29nbGUgTExDLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5kZWNsYXJlIGxldCBhbmd1bGFyOiB7XHJcbiAgICBib290c3RyYXA6IChlOiBFbGVtZW50LCBtb2R1bGVzOiAoc3RyaW5nIHwgSUluamVjdGFibGUpW10sIGNvbmZpZz86IElBbmd1bGFyQm9vdHN0cmFwQ29uZmlnKSA9PiBJSW5qZWN0b3JTZXJ2aWNlO1xyXG4gICAgbW9kdWxlOiAocHJlZml4OiBzdHJpbmcsIGRlcGVuZGVuY2llcz86IHN0cmluZ1tdKSA9PiBJTW9kdWxlO1xyXG4gICAgZWxlbWVudDoge1xyXG4gICAgICAgIChlOiBzdHJpbmcgfCBFbGVtZW50IHwgRG9jdW1lbnQgfCBJQXVnbWVudGVkSlF1ZXJ5KTogSUF1Z21lbnRlZEpRdWVyeTtcclxuICAgICAgICBjbGVhbkRhdGE6IChub2RlczogTm9kZVtdIHwgTm9kZUxpc3QpID0+IHZvaWQ7XHJcbiAgICB9O1xyXG4gICAgaW5qZWN0b3I6IChtb2R1bGVzOiBBcnJheTxzdHJpbmcgfCBJSW5qZWN0YWJsZT4sIHN0cmljdERpPzogYm9vbGVhbikgPT4gSUluamVjdG9yU2VydmljZTtcclxuICAgIHZlcnNpb246IHtcclxuICAgICAgICBtYWpvcjogbnVtYmVyO1xyXG4gICAgfTtcclxuICAgIHJlc3VtZUJvb3RzdHJhcDogKCkgPT4gdm9pZDtcclxuICAgIGdldFRlc3RhYmlsaXR5OiAoZTogRWxlbWVudCkgPT4gSVRlc3RhYmlsaXR5U2VydmljZTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gdXNlIHdoZW4gdW5pdCB0ZXN0aW5nIEFuZ3VsYXJKUyBzZXJ2aWNlcyB0aGF0IGRlcGVuZCB1cG9uIGRvd25ncmFkZWQgQW5ndWxhclxyXG4gKiBzZXJ2aWNlcy5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIEFuZ3VsYXJKUyBtb2R1bGUgdGhhdCBpcyBjb25maWd1cmVkIHRvIHdpcmUgdXAgdGhlIEFuZ3VsYXJKUyBhbmQgQW5ndWxhclxyXG4gKiBpbmplY3RvcnMgd2l0aG91dCB0aGUgbmVlZCB0byBhY3R1YWxseSBib290c3RyYXAgYSBoeWJyaWQgYXBwbGljYXRpb24uXHJcbiAqIFRoaXMgbWFrZXMgaXQgc2ltcGxlciBhbmQgZmFzdGVyIHRvIHVuaXQgdGVzdCBzZXJ2aWNlcy5cclxuICpcclxuICogVXNlIHRoZSByZXR1cm5lZCBBbmd1bGFySlMgbW9kdWxlIGluIGEgY2FsbCB0b1xyXG4gKiBbYGFuZ3VsYXIubW9ja3MubW9kdWxlYF0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nTW9jay9mdW5jdGlvbi9hbmd1bGFyLm1vY2subW9kdWxlKSB0b1xyXG4gKiBpbmNsdWRlIHRoaXMgbW9kdWxlIGluIHRoZSB1bml0IHRlc3QgaW5qZWN0b3IuXHJcbiAqXHJcbiAqIEluIHRoZSBmb2xsb3dpbmcgY29kZSBzbmlwcGV0LCB3ZSBhcmUgY29uZmlndXJpbmcgdGhlIGAkaW5qZWN0b3JgIHdpdGggdHdvIG1vZHVsZXM6XHJcbiAqIFRoZSBBbmd1bGFySlMgYG5nMUFwcE1vZHVsZWAsIHdoaWNoIGlzIHRoZSBBbmd1bGFySlMgcGFydCBvZiBvdXIgaHlicmlkIGFwcGxpY2F0aW9uIGFuZCB0aGVcclxuICogYE5nMkFwcE1vZHVsZWAsIHdoaWNoIGlzIHRoZSBBbmd1bGFyIHBhcnQuXHJcbiAqXHJcbiAqIDxjb2RlLWV4YW1wbGUgcGF0aD1cInVwZ3JhZGUvc3RhdGljL3RzL2Z1bGwvbW9kdWxlLnNwZWMudHNcIlxyXG4gKiByZWdpb249XCJhbmd1bGFyanMtc2V0dXBcIj48L2NvZGUtZXhhbXBsZT5cclxuICpcclxuICogT25jZSB0aGlzIGlzIGRvbmUgd2UgY2FuIGdldCBob2xkIG9mIHNlcnZpY2VzIHZpYSB0aGUgQW5ndWxhckpTIGAkaW5qZWN0b3JgIGFzIG5vcm1hbC5cclxuICogU2VydmljZXMgdGhhdCBhcmUgKG9yIGhhdmUgZGVwZW5kZW5jaWVzIG9uKSBhIGRvd25ncmFkZWQgQW5ndWxhciBzZXJ2aWNlLCB3aWxsIGJlIGluc3RhbnRpYXRlZCBhc1xyXG4gKiBuZWVkZWQgYnkgdGhlIEFuZ3VsYXIgcm9vdCBgSW5qZWN0b3JgLlxyXG4gKlxyXG4gKiBJbiB0aGUgZm9sbG93aW5nIGNvZGUgc25pcHBldCwgYGhlcm9lc1NlcnZpY2VgIGlzIGEgZG93bmdyYWRlZCBBbmd1bGFyIHNlcnZpY2UgdGhhdCB3ZSBhcmVcclxuICogYWNjZXNzaW5nIGZyb20gQW5ndWxhckpTLlxyXG4gKlxyXG4gKiA8Y29kZS1leGFtcGxlIHBhdGg9XCJ1cGdyYWRlL3N0YXRpYy90cy9mdWxsL21vZHVsZS5zcGVjLnRzXCJcclxuICogcmVnaW9uPVwiYW5ndWxhcmpzLXNwZWNcIj48L2NvZGUtZXhhbXBsZT5cclxuICpcclxuICogPGRpdiBjbGFzcz1cImFsZXJ0IGlzLWltcG9ydGFudFwiPlxyXG4gKlxyXG4gKiBUaGlzIGhlbHBlciBpcyBmb3IgdGVzdGluZyBzZXJ2aWNlcyBub3QgY29tcG9uZW50cy5cclxuICogRm9yIENvbXBvbmVudCB0ZXN0aW5nIHlvdSBtdXN0IHN0aWxsIGJvb3RzdHJhcCBhIGh5YnJpZCBhcHAuIFNlZSBgVXBncmFkZU1vZHVsZWAgb3JcclxuICogYGRvd25ncmFkZU1vZHVsZWAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIDwvZGl2PlxyXG4gKlxyXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgaXMtaW1wb3J0YW50XCI+XHJcbiAqXHJcbiAqIFRoZSByZXN1bHRpbmcgY29uZmlndXJhdGlvbiBkb2VzIG5vdCB3aXJlIHVwIEFuZ3VsYXJKUyBkaWdlc3RzIHRvIFpvbmUgaG9va3MuIEl0IGlzIHRoZVxyXG4gKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgdGVzdCB3cml0ZXIgdG8gY2FsbCBgJHJvb3RTY29wZS4kYXBwbHlgLCBhcyBuZWNlc3NhcnksIHRvIHRyaWdnZXJcclxuICogQW5ndWxhckpTIGhhbmRsZXJzIG9mIGFzeW5jIGV2ZW50cyBmcm9tIEFuZ3VsYXIuXHJcbiAqXHJcbiAqIDwvZGl2PlxyXG4gKlxyXG4gKiA8ZGl2IGNsYXNzPVwiYWxlcnQgaXMtaW1wb3J0YW50XCI+XHJcbiAqXHJcbiAqIFRoZSBoZWxwZXIgc2V0cyB1cCBnbG9iYWwgdmFyaWFibGVzIHRvIGhvbGQgdGhlIHNoYXJlZCBBbmd1bGFyIGFuZCBBbmd1bGFySlMgaW5qZWN0b3JzLlxyXG4gKlxyXG4gKiAqIE9ubHkgY2FsbCB0aGlzIGhlbHBlciBvbmNlIHBlciBzcGVjLlxyXG4gKiAqIERvIG5vdCB1c2UgYGNyZWF0ZUFuZ3VsYXJKU1Rlc3RpbmdNb2R1bGVgIGluIHRoZSBzYW1lIHNwZWMgYXMgYGNyZWF0ZUFuZ3VsYXJUZXN0aW5nTW9kdWxlYC5cclxuICpcclxuICogPC9kaXY+XHJcbiAqXHJcbiAqIEhlcmUgaXMgdGhlIGV4YW1wbGUgYXBwbGljYXRpb24gYW5kIGl0cyB1bml0IHRlc3RzIHRoYXQgdXNlIGBjcmVhdGVBbmd1bGFyVGVzdGluZ01vZHVsZWBcclxuICogYW5kIGBjcmVhdGVBbmd1bGFySlNUZXN0aW5nTW9kdWxlYC5cclxuICpcclxuICogPGNvZGUtdGFicz5cclxuICogIDxjb2RlLXBhbmUgaGVhZGVyPVwibW9kdWxlLnNwZWMudHNcIiBwYXRoPVwidXBncmFkZS9zdGF0aWMvdHMvZnVsbC9tb2R1bGUuc3BlYy50c1wiPjwvY29kZS1wYW5lPlxyXG4gKiAgPGNvZGUtcGFuZSBoZWFkZXI9XCJtb2R1bGUudHNcIiBwYXRoPVwidXBncmFkZS9zdGF0aWMvdHMvZnVsbC9tb2R1bGUudHNcIj48L2NvZGUtcGFuZT5cclxuICogPC9jb2RlLXRhYnM+XHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSBhbmd1bGFyTW9kdWxlcyBhIGNvbGxlY3Rpb24gb2YgQW5ndWxhciBtb2R1bGVzIHRvIGluY2x1ZGUgaW4gdGhlIGNvbmZpZ3VyYXRpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNBcGlcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGNyZWF0ZUFuZ3VsYXJKU1Rlc3RpbmdNb2R1bGUoYW5ndWxhck1vZHVsZXM6IGFueVtdKTogc3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIHVuaXQgdGVzdGluZyBBbmd1bGFyIHNlcnZpY2VzIHRoYXQgZGVwZW5kIHVwb24gdXBncmFkZWQgQW5ndWxhckpTXHJcbiAqIHNlcnZpY2VzLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYE5nTW9kdWxlYCBkZWNvcmF0ZWQgY2xhc3MgdGhhdCBpcyBjb25maWd1cmVkIHRvIHdpcmUgdXAgdGhlIEFuZ3VsYXJcclxuICogYW5kIEFuZ3VsYXJKUyBpbmplY3RvcnMgd2l0aG91dCB0aGUgbmVlZCB0byBhY3R1YWxseSBib290c3RyYXAgYSBoeWJyaWQgYXBwbGljYXRpb24uXHJcbiAqIFRoaXMgbWFrZXMgaXQgc2ltcGxlciBhbmQgZmFzdGVyIHRvIHVuaXQgdGVzdCBzZXJ2aWNlcy5cclxuICpcclxuICogVXNlIHRoZSByZXR1cm5lZCBjbGFzcyBhcyBhbiBcImltcG9ydFwiIHdoZW4gY29uZmlndXJpbmcgdGhlIGBUZXN0QmVkYC5cclxuICpcclxuICogSW4gdGhlIGZvbGxvd2luZyBjb2RlIHNuaXBwZXQsIHdlIGFyZSBjb25maWd1cmluZyB0aGUgVGVzdEJlZCB3aXRoIHR3byBpbXBvcnRzLlxyXG4gKiBUaGUgYE5nMkFwcE1vZHVsZWAgaXMgdGhlIEFuZ3VsYXIgcGFydCBvZiBvdXIgaHlicmlkIGFwcGxpY2F0aW9uIGFuZCB0aGUgYG5nMUFwcE1vZHVsZWAgaXMgdGhlXHJcbiAqIEFuZ3VsYXJKUyBwYXJ0LlxyXG4gKlxyXG4gKiA8Y29kZS1leGFtcGxlIHBhdGg9XCJ1cGdyYWRlL3N0YXRpYy90cy9mdWxsL21vZHVsZS5zcGVjLnRzXCIgcmVnaW9uPVwiYW5ndWxhci1zZXR1cFwiPjwvY29kZS1leGFtcGxlPlxyXG4gKlxyXG4gKiBPbmNlIHRoaXMgaXMgZG9uZSB3ZSBjYW4gZ2V0IGhvbGQgb2Ygc2VydmljZXMgdmlhIHRoZSBBbmd1bGFyIGBJbmplY3RvcmAgYXMgbm9ybWFsLlxyXG4gKiBTZXJ2aWNlcyB0aGF0IGFyZSAob3IgaGF2ZSBkZXBlbmRlbmNpZXMgb24pIGFuIHVwZ3JhZGVkIEFuZ3VsYXJKUyBzZXJ2aWNlLCB3aWxsIGJlIGluc3RhbnRpYXRlZFxyXG4gKiBhcyBuZWVkZWQgYnkgdGhlIEFuZ3VsYXJKUyBgJGluamVjdG9yYC5cclxuICpcclxuICogSW4gdGhlIGZvbGxvd2luZyBjb2RlIHNuaXBwZXQsIGBIZXJvZXNTZXJ2aWNlYCBpcyBhbiBBbmd1bGFyIHNlcnZpY2UgdGhhdCBkZXBlbmRzIHVwb24gYW5cclxuICogQW5ndWxhckpTIHNlcnZpY2UsIGB0aXRsZUNhc2VgLlxyXG4gKlxyXG4gKiA8Y29kZS1leGFtcGxlIHBhdGg9XCJ1cGdyYWRlL3N0YXRpYy90cy9mdWxsL21vZHVsZS5zcGVjLnRzXCIgcmVnaW9uPVwiYW5ndWxhci1zcGVjXCI+PC9jb2RlLWV4YW1wbGU+XHJcbiAqXHJcbiAqIDxkaXYgY2xhc3M9XCJhbGVydCBpcy1pbXBvcnRhbnRcIj5cclxuICpcclxuICogVGhpcyBoZWxwZXIgaXMgZm9yIHRlc3Rpbmcgc2VydmljZXMgbm90IENvbXBvbmVudHMuXHJcbiAqIEZvciBDb21wb25lbnQgdGVzdGluZyB5b3UgbXVzdCBzdGlsbCBib290c3RyYXAgYSBoeWJyaWQgYXBwLiBTZWUgYFVwZ3JhZGVNb2R1bGVgIG9yXHJcbiAqIGBkb3duZ3JhZGVNb2R1bGVgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiA8L2Rpdj5cclxuICpcclxuICogPGRpdiBjbGFzcz1cImFsZXJ0IGlzLWltcG9ydGFudFwiPlxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0aW5nIGNvbmZpZ3VyYXRpb24gZG9lcyBub3Qgd2lyZSB1cCBBbmd1bGFySlMgZGlnZXN0cyB0byBab25lIGhvb2tzLiBJdCBpcyB0aGVcclxuICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIHRlc3Qgd3JpdGVyIHRvIGNhbGwgYCRyb290U2NvcGUuJGFwcGx5YCwgYXMgbmVjZXNzYXJ5LCB0byB0cmlnZ2VyXHJcbiAqIEFuZ3VsYXJKUyBoYW5kbGVycyBvZiBhc3luYyBldmVudHMgZnJvbSBBbmd1bGFyLlxyXG4gKlxyXG4gKiA8L2Rpdj5cclxuICpcclxuICogPGRpdiBjbGFzcz1cImFsZXJ0IGlzLWltcG9ydGFudFwiPlxyXG4gKlxyXG4gKiBUaGUgaGVscGVyIHNldHMgdXAgZ2xvYmFsIHZhcmlhYmxlcyB0byBob2xkIHRoZSBzaGFyZWQgQW5ndWxhciBhbmQgQW5ndWxhckpTIGluamVjdG9ycy5cclxuICpcclxuICogKiBPbmx5IGNhbGwgdGhpcyBoZWxwZXIgb25jZSBwZXIgc3BlYy5cclxuICogKiBEbyBub3QgdXNlIGBjcmVhdGVBbmd1bGFyVGVzdGluZ01vZHVsZWAgaW4gdGhlIHNhbWUgc3BlYyBhcyBgY3JlYXRlQW5ndWxhckpTVGVzdGluZ01vZHVsZWAuXHJcbiAqXHJcbiAqIDwvZGl2PlxyXG4gKlxyXG4gKiBIZXJlIGlzIHRoZSBleGFtcGxlIGFwcGxpY2F0aW9uIGFuZCBpdHMgdW5pdCB0ZXN0cyB0aGF0IHVzZSBgY3JlYXRlQW5ndWxhclRlc3RpbmdNb2R1bGVgXHJcbiAqIGFuZCBgY3JlYXRlQW5ndWxhckpTVGVzdGluZ01vZHVsZWAuXHJcbiAqXHJcbiAqIDxjb2RlLXRhYnM+XHJcbiAqICA8Y29kZS1wYW5lIGhlYWRlcj1cIm1vZHVsZS5zcGVjLnRzXCIgcGF0aD1cInVwZ3JhZGUvc3RhdGljL3RzL2Z1bGwvbW9kdWxlLnNwZWMudHNcIj48L2NvZGUtcGFuZT5cclxuICogIDxjb2RlLXBhbmUgaGVhZGVyPVwibW9kdWxlLnRzXCIgcGF0aD1cInVwZ3JhZGUvc3RhdGljL3RzL2Z1bGwvbW9kdWxlLnRzXCI+PC9jb2RlLXBhbmU+XHJcbiAqIDwvY29kZS10YWJzPlxyXG4gKlxyXG4gKlxyXG4gKiBAcGFyYW0gYW5ndWxhckpTTW9kdWxlcyBhIGNvbGxlY3Rpb24gb2YgdGhlIG5hbWVzIG9mIEFuZ3VsYXJKUyBtb2R1bGVzIHRvIGluY2x1ZGUgaW4gdGhlXHJcbiAqIGNvbmZpZ3VyYXRpb24uXHJcbiAqIEBwYXJhbSBbc3RyaWN0RGldIHdoZXRoZXIgdGhlIEFuZ3VsYXJKUyBpbmplY3RvciBzaG91bGQgaGF2ZSBgc3RyaWN0RElgIGVuYWJsZWQuXHJcbiAqXHJcbiAqIEBwdWJsaWNBcGlcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGNyZWF0ZUFuZ3VsYXJUZXN0aW5nTW9kdWxlKGFuZ3VsYXJKU01vZHVsZXM6IHN0cmluZ1tdLCBzdHJpY3REaT86IGJvb2xlYW4pOiBUeXBlPGFueT47XHJcblxyXG5kZWNsYXJlIHR5cGUgRGlyZWN0aXZlUmVxdWlyZVByb3BlcnR5ID0gU2luZ2xlT3JMaXN0T3JNYXA8c3RyaW5nPjtcclxuXHJcbmRlY2xhcmUgdHlwZSBEaXJlY3RpdmVUcmFuc2NsdWRlUHJvcGVydHkgPSBib29sZWFuIHwgJ2VsZW1lbnQnIHwge1xyXG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nO1xyXG59O1xyXG5cclxuZGVjbGFyZSBpbnRlcmZhY2UgSUFuZ3VsYXJCb290c3RyYXBDb25maWcge1xyXG4gICAgc3RyaWN0RGk/OiBib29sZWFuO1xyXG59XHJcblxyXG5kZWNsYXJlIGludGVyZmFjZSBJQW5ub3RhdGVkRnVuY3Rpb24gZXh0ZW5kcyBGdW5jdGlvbiB7XHJcbiAgICAkaW5qZWN0PzogRnVuY3Rpb24gZXh0ZW5kcyB7XHJcbiAgICAgICAgJGluamVjdD86IHN0cmluZ1tdO1xyXG4gICAgfSA/IE5nMVRva2VuW10gOiBSZWFkb25seUFycmF5PE5nMVRva2VuPjtcclxufVxyXG5cclxuZGVjbGFyZSB0eXBlIElBdWdtZW50ZWRKUXVlcnkgPSBOb2RlW10gJiB7XHJcbiAgICBvbj86IChuYW1lOiBzdHJpbmcsIGZuOiAoKSA9PiB2b2lkKSA9PiB2b2lkO1xyXG4gICAgZGF0YT86IChuYW1lOiBzdHJpbmcsIHZhbHVlPzogYW55KSA9PiBhbnk7XHJcbiAgICB0ZXh0PzogKCkgPT4gc3RyaW5nO1xyXG4gICAgaW5oZXJpdGVkRGF0YT86IChuYW1lOiBzdHJpbmcsIHZhbHVlPzogYW55KSA9PiBhbnk7XHJcbiAgICBjb250ZW50cz86ICgpID0+IElBdWdtZW50ZWRKUXVlcnk7XHJcbiAgICBwYXJlbnQ/OiAoKSA9PiBJQXVnbWVudGVkSlF1ZXJ5O1xyXG4gICAgZW1wdHk/OiAoKSA9PiB2b2lkO1xyXG4gICAgYXBwZW5kPzogKGNvbnRlbnQ6IElBdWdtZW50ZWRKUXVlcnkgfCBzdHJpbmcpID0+IElBdWdtZW50ZWRKUXVlcnk7XHJcbiAgICBjb250cm9sbGVyPzogKG5hbWU6IHN0cmluZykgPT4gYW55O1xyXG4gICAgaXNvbGF0ZVNjb3BlPzogKCkgPT4gSVNjb3BlO1xyXG4gICAgaW5qZWN0b3I/OiAoKSA9PiBJSW5qZWN0b3JTZXJ2aWNlO1xyXG4gICAgdHJpZ2dlckhhbmRsZXI/OiAoZXZlbnRUeXBlT3JPYmplY3Q6IHN0cmluZyB8IEV2ZW50LCBleHRyYVBhcmFtZXRlcnM/OiBhbnlbXSkgPT4gSUF1Z21lbnRlZEpRdWVyeTtcclxuICAgIHJlbW92ZT86ICgpID0+IHZvaWQ7XHJcbiAgICByZW1vdmVEYXRhPzogKCkgPT4gdm9pZDtcclxufTtcclxuXHJcbmRlY2xhcmUgaW50ZXJmYWNlIElDb21wb25lbnQge1xyXG4gICAgYmluZGluZ3M/OiB7XHJcbiAgICAgICAgW2tleTogc3RyaW5nXTogc3RyaW5nO1xyXG4gICAgfTtcclxuICAgIGNvbnRyb2xsZXI/OiBzdHJpbmcgfCBJSW5qZWN0YWJsZTtcclxuICAgIGNvbnRyb2xsZXJBcz86IHN0cmluZztcclxuICAgIHJlcXVpcmU/OiBEaXJlY3RpdmVSZXF1aXJlUHJvcGVydHk7XHJcbiAgICB0ZW1wbGF0ZT86IHN0cmluZyB8IEZ1bmN0aW9uO1xyXG4gICAgdGVtcGxhdGVVcmw/OiBzdHJpbmcgfCBGdW5jdGlvbjtcclxuICAgIHRyYW5zY2x1ZGU/OiBEaXJlY3RpdmVUcmFuc2NsdWRlUHJvcGVydHk7XHJcbn1cclxuXHJcbmRlY2xhcmUgdHlwZSBJSW5qZWN0YWJsZSA9IChOZzFUb2tlbiB8IEZ1bmN0aW9uKVtdIHwgSUFubm90YXRlZEZ1bmN0aW9uO1xyXG5cclxuZGVjbGFyZSBpbnRlcmZhY2UgSUluamVjdG9yU2VydmljZSB7XHJcbiAgICBnZXQoa2V5OiBzdHJpbmcpOiBhbnk7XHJcbiAgICBoYXMoa2V5OiBzdHJpbmcpOiBib29sZWFuO1xyXG59XHJcblxyXG5kZWNsYXJlIGludGVyZmFjZSBJTW9kdWxlIHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHJlcXVpcmVzOiAoc3RyaW5nIHwgSUluamVjdGFibGUpW107XHJcbiAgICBjb25maWcoZm46IElJbmplY3RhYmxlKTogSU1vZHVsZTtcclxuICAgIGRpcmVjdGl2ZShzZWxlY3Rvcjogc3RyaW5nLCBmYWN0b3J5OiBJSW5qZWN0YWJsZSk6IElNb2R1bGU7XHJcbiAgICBjb21wb25lbnQoc2VsZWN0b3I6IHN0cmluZywgY29tcG9uZW50OiBJQ29tcG9uZW50KTogSU1vZHVsZTtcclxuICAgIGNvbnRyb2xsZXIobmFtZTogc3RyaW5nLCB0eXBlOiBJSW5qZWN0YWJsZSk6IElNb2R1bGU7XHJcbiAgICBmYWN0b3J5KGtleTogTmcxVG9rZW4sIGZhY3RvcnlGbjogSUluamVjdGFibGUpOiBJTW9kdWxlO1xyXG4gICAgdmFsdWUoa2V5OiBOZzFUb2tlbiwgdmFsdWU6IGFueSk6IElNb2R1bGU7XHJcbiAgICBjb25zdGFudCh0b2tlbjogTmcxVG9rZW4sIHZhbHVlOiBhbnkpOiBJTW9kdWxlO1xyXG4gICAgcnVuKGE6IElJbmplY3RhYmxlKTogSU1vZHVsZTtcclxufVxyXG5cclxuZGVjbGFyZSBpbnRlcmZhY2UgSVJvb3RTY29wZVNlcnZpY2Uge1xyXG4gICAgJG5ldyhpc29sYXRlPzogYm9vbGVhbik6IElTY29wZTtcclxuICAgICRpZDogc3RyaW5nO1xyXG4gICAgJHBhcmVudDogSVNjb3BlO1xyXG4gICAgJHJvb3Q6IElTY29wZTtcclxuICAgICR3YXRjaChleHA6IE5nMUV4cHJlc3Npb24sIGZuPzogKGExPzogYW55LCBhMj86IGFueSkgPT4gdm9pZCk6IEZ1bmN0aW9uO1xyXG4gICAgJG9uKGV2ZW50OiBzdHJpbmcsIGZuPzogKGV2ZW50PzogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IEZ1bmN0aW9uO1xyXG4gICAgJGRlc3Ryb3koKTogYW55O1xyXG4gICAgJGFwcGx5KGV4cD86IE5nMUV4cHJlc3Npb24pOiBhbnk7XHJcbiAgICAkZGlnZXN0KCk6IGFueTtcclxuICAgICRldmFsQXN5bmMoZXhwOiBOZzFFeHByZXNzaW9uLCBsb2NhbHM/OiBhbnkpOiB2b2lkO1xyXG4gICAgJG9uKGV2ZW50OiBzdHJpbmcsIGZuPzogKGV2ZW50PzogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IEZ1bmN0aW9uO1xyXG4gICAgJCRjaGlsZFRhaWw6IElTY29wZTtcclxuICAgICQkY2hpbGRIZWFkOiBJU2NvcGU7XHJcbiAgICAkJG5leHRTaWJsaW5nOiBJU2NvcGU7XHJcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XHJcbn1cclxuXHJcbmRlY2xhcmUgaW50ZXJmYWNlIElTY29wZSBleHRlbmRzIElSb290U2NvcGVTZXJ2aWNlIHtcclxufVxyXG5cclxuZGVjbGFyZSBpbnRlcmZhY2UgSVRlc3RhYmlsaXR5U2VydmljZSB7XHJcbiAgICBmaW5kQmluZGluZ3MoZWxlbWVudDogRWxlbWVudCwgZXhwcmVzc2lvbjogc3RyaW5nLCBvcHRfZXhhY3RNYXRjaD86IGJvb2xlYW4pOiBFbGVtZW50W107XHJcbiAgICBmaW5kTW9kZWxzKGVsZW1lbnQ6IEVsZW1lbnQsIGV4cHJlc3Npb246IHN0cmluZywgb3B0X2V4YWN0TWF0Y2g/OiBib29sZWFuKTogRWxlbWVudFtdO1xyXG4gICAgZ2V0TG9jYXRpb24oKTogc3RyaW5nO1xyXG4gICAgc2V0TG9jYXRpb24odXJsOiBzdHJpbmcpOiB2b2lkO1xyXG4gICAgd2hlblN0YWJsZShjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkO1xyXG59XHJcblxyXG5kZWNsYXJlIHR5cGUgTmcxRXhwcmVzc2lvbiA9IHN0cmluZyB8IEZ1bmN0aW9uO1xyXG5cclxuXHJcbmRlY2xhcmUgdHlwZSBOZzFUb2tlbiA9IHN0cmluZztcclxuXHJcbmRlY2xhcmUgdHlwZSBTaW5nbGVPckxpc3RPck1hcDxUPiA9IFQgfCBUW10gfCB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBUO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlY2xhcmUgY29uc3QgybVhbmd1bGFyX3BhY2thZ2VzX3VwZ3JhZGVfc3RhdGljX3Rlc3RpbmdfdGVzdGluZ19hOiB0eXBlb2YgYW5ndWxhci5tb2R1bGU7XHJcblxyXG5leHBvcnQgZGVjbGFyZSBjb25zdCDJtWFuZ3VsYXJfcGFja2FnZXNfdXBncmFkZV9zdGF0aWNfdGVzdGluZ190ZXN0aW5nX2IgPSBcIiQkYW5ndWxhclVwZ3JhZGVBcHBUeXBlXCI7XHJcblxyXG5leHBvcnQgZGVjbGFyZSBjb25zdCBlbnVtIMm1YW5ndWxhcl9wYWNrYWdlc191cGdyYWRlX3N0YXRpY190ZXN0aW5nX3Rlc3RpbmdfYyB7XHJcbiAgICBOb25lID0gMCxcclxuICAgIER5bmFtaWMgPSAxLFxyXG4gICAgU3RhdGljID0gMixcclxuICAgIExpdGUgPSAzXHJcbn1cclxuXHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IMm1YW5ndWxhcl9wYWNrYWdlc191cGdyYWRlX3N0YXRpY190ZXN0aW5nX3Rlc3RpbmdfZCA9IFwiJCRhbmd1bGFySW5qZWN0b3JcIjtcclxuXHJcbmV4cG9ydCB7IH1cclxuIl19