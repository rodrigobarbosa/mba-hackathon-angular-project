/**
 * @license Angular v9.1.12
 * (c) 2010-2020 Google LLC. https://angular.io/
 * License: MIT
 */

import { HashLocationStrategy } from '@angular/common';
import { InjectionToken } from '@angular/core';
import { Location } from '@angular/common';
import { LocationStrategy } from '@angular/common';
import { ModuleWithProviders } from '@angular/core';
import { PathLocationStrategy } from '@angular/common';
import { PlatformLocation } from '@angular/common';
import { UpgradeModule } from '@angular/upgrade/static';

/**
 * Location service that provides a drop-in replacement for the $location service
 * provided in AngularJS.
 *
 * @see [Using the Angular Unified Location Service](guide/upgrade#using-the-unified-angular-location-service)
 *
 * @publicApi
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
export declare class $locationShim {
    private location;
    private platformLocation;
    private urlCodec;
    private locationStrategy;
    private initalizing;
    private updateBrowser;
    private $$absUrl;
    private $$url;
    private $$protocol;
    private $$host;
    private $$port;
    private $$replace;
    private $$path;
    private $$search;
    private $$hash;
    private $$state;
    private $$changeListeners;
    private cachedState;
    private urlChanges;
    constructor($injector: any, location: Location, platformLocation: PlatformLocation, urlCodec: UrlCodec, locationStrategy: LocationStrategy);
    private initialize;
    private resetBrowserUpdate;
    private lastHistoryState;
    private lastBrowserUrl;
    private browserUrl;
    private lastCachedState;
    private cacheState;
    /**
     * This function emulates the $browser.state() function from AngularJS. It will cause
     * history.state to be cached unless changed with deep equality check.
     */
    private browserState;
    private stripBaseUrl;
    private getServerBase;
    private parseAppUrl;
    /**
     * Registers listeners for URL changes. This API is used to catch updates performed by the
     * AngularJS framework. These changes are a subset of the `$locationChangeStart` and
     * `$locationChangeSuccess` events which fire when AngularJS updates its internally-referenced
     * version of the browser URL.
     *
     * It's possible for `$locationChange` events to happen, but for the browser URL
     * (window.location) to remain unchanged. This `onChange` callback will fire only when AngularJS
     * actually updates the browser URL (window.location).
     *
     * @param fn The callback function that is triggered for the listener when the URL changes.
     * @param err The callback function that is triggered when an error occurs.
     */
    onChange(fn: (url: string, state: unknown, oldUrl: string, oldState: unknown) => void, err?: (e: Error) => void): void;
    /**
     * Parses the provided URL, and sets the current URL to the parsed result.
     *
     * @param url The URL string.
     */
    $$parse(url: string): void;
    /**
     * Parses the provided URL and its relative URL.
     *
     * @param url The full URL string.
     * @param relHref A URL string relative to the full URL string.
     */
    $$parseLinkUrl(url: string, relHref?: string | null): boolean;
    private setBrowserUrlWithFallback;
    private composeUrls;
    /**
     * Retrieves the full URL representation with all segments encoded according to
     * rules specified in
     * [RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).
     *
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let absUrl = $location.absUrl();
     * // => "http://example.com/#/some/path?foo=bar&baz=xoxo"
     * ```
     */
    absUrl(): string;
    /**
     * Retrieves the current URL, or sets a new URL. When setting a URL,
     * changes the path, search, and hash, and returns a reference to its own instance.
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let url = $location.url();
     * // => "/some/path?foo=bar&baz=xoxo"
     * ```
     */
    url(): string;
    url(url: string): this;
    /**
     * Retrieves the protocol of the current URL.
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let protocol = $location.protocol();
     * // => "http"
     * ```
     */
    protocol(): string;
    /**
     * Retrieves the protocol of the current URL.
     *
     * In contrast to the non-AngularJS version `location.host` which returns `hostname:port`, this
     * returns the `hostname` portion only.
     *
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let host = $location.host();
     * // => "example.com"
     *
     * // given URL http://user:password@example.com:8080/#/some/path?foo=bar&baz=xoxo
     * host = $location.host();
     * // => "example.com"
     * host = location.host;
     * // => "example.com:8080"
     * ```
     */
    host(): string;
    /**
     * Retrieves the port of the current URL.
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let port = $location.port();
     * // => 80
     * ```
     */
    port(): number | null;
    /**
     * Retrieves the path of the current URL, or changes the path and returns a reference to its own
     * instance.
     *
     * Paths should always begin with forward slash (/). This method adds the forward slash
     * if it is missing.
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let path = $location.path();
     * // => "/some/path"
     * ```
     */
    path(): string;
    path(path: string | number | null): this;
    /**
     * Retrieves a map of the search parameters of the current URL, or changes a search
     * part and returns a reference to its own instance.
     *
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let searchObject = $location.search();
     * // => {foo: 'bar', baz: 'xoxo'}
     *
     * // set foo to 'yipee'
     * $location.search('foo', 'yipee');
     * // $location.search() => {foo: 'yipee', baz: 'xoxo'}
     * ```
     *
     * @param {string|Object.<string>|Object.<Array.<string>>} search New search params - string or
     * hash object.
     *
     * When called with a single argument the method acts as a setter, setting the `search` component
     * of `$location` to the specified value.
     *
     * If the argument is a hash object containing an array of values, these values will be encoded
     * as duplicate search parameters in the URL.
     *
     * @param {(string|Number|Array<string>|boolean)=} paramValue If `search` is a string or number,
     *     then `paramValue`
     * will override only a single search property.
     *
     * If `paramValue` is an array, it will override the property of the `search` component of
     * `$location` specified via the first argument.
     *
     * If `paramValue` is `null`, the property specified via the first argument will be deleted.
     *
     * If `paramValue` is `true`, the property specified via the first argument will be added with no
     * value nor trailing equal sign.
     *
     * @return {Object} The parsed `search` object of the current URL, or the changed `search` object.
     */
    search(): {
        [key: string]: unknown;
    };
    search(search: string | number | {
        [key: string]: unknown;
    }): this;
    search(search: string | number | {
        [key: string]: unknown;
    }, paramValue: null | undefined | string | number | boolean | string[]): this;
    /**
     * Retrieves the current hash fragment, or changes the hash fragment and returns a reference to
     * its own instance.
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo#hashValue
     * let hash = $location.hash();
     * // => "hashValue"
     * ```
     */
    hash(): string;
    hash(hash: string | number | null): this;
    /**
     * Changes to `$location` during the current `$digest` will replace the current
     * history record, instead of adding a new one.
     */
    replace(): this;
    /**
     * Retrieves the history state object when called without any parameter.
     *
     * Change the history state object when called with one parameter and return `$location`.
     * The state object is later passed to `pushState` or `replaceState`.
     *
     * This method is supported only in HTML5 mode and only in browsers supporting
     * the HTML5 History API methods such as `pushState` and `replaceState`. If you need to support
     * older browsers (like IE9 or Android < 4.0), don't use this method.
     *
     */
    state(): unknown;
    state(state: unknown): this;
}

/**
 * The factory function used to create an instance of the `$locationShim` in Angular,
 * and provides an API-compatiable `$locationProvider` for AngularJS.
 *
 * @publicApi
 */
export declare class $locationShimProvider {
    private ngUpgrade;
    private location;
    private platformLocation;
    private urlCodec;
    private locationStrategy;
    constructor(ngUpgrade: UpgradeModule, location: Location, platformLocation: PlatformLocation, urlCodec: UrlCodec, locationStrategy: LocationStrategy);
    /**
     * Factory method that returns an instance of the $locationShim
     */
    $get(): $locationShim;
    /**
     * Stub method used to keep API compatible with AngularJS. This setting is configured through
     * the LocationUpgradeModule's `config` method in your Angular app.
     */
    hashPrefix(prefix?: string): void;
    /**
     * Stub method used to keep API compatible with AngularJS. This setting is configured through
     * the LocationUpgradeModule's `config` method in your Angular app.
     */
    html5Mode(mode?: any): void;
}

/**
 * A `UrlCodec` that uses logic from AngularJS to serialize and parse URLs
 * and URL parameters.
 *
 * @publicApi
 */
export declare class AngularJSUrlCodec implements UrlCodec {
    encodePath(path: string): string;
    encodeSearch(search: string | {
        [k: string]: unknown;
    }): string;
    encodeHash(hash: string): string;
    decodePath(path: string, html5Mode?: boolean): string;
    decodeSearch(search: string): {
        [k: string]: unknown;
    };
    decodeHash(hash: string): string;
    normalize(href: string): string;
    normalize(path: string, search: {
        [k: string]: unknown;
    }, hash: string, baseUrl?: string): string;
    areEqual(valA: string, valB: string): boolean;
    parse(url: string, base?: string): {
        href: string;
        protocol: string;
        host: string;
        search: string;
        hash: string;
        hostname: string;
        port: string;
        pathname: string;
    };
}

/**
 * A provider token used to configure the location upgrade module.
 *
 * @publicApi
 */
export declare const LOCATION_UPGRADE_CONFIGURATION: InjectionToken<LocationUpgradeConfig>;

/**
 * Configuration options for LocationUpgrade.
 *
 * @publicApi
 */
export declare interface LocationUpgradeConfig {
    /**
     * Configures whether the location upgrade module should use the `HashLocationStrategy`
     * or the `PathLocationStrategy`
     */
    useHash?: boolean;
    /**
     * Configures the hash prefix used in the URL when using the `HashLocationStrategy`
     */
    hashPrefix?: string;
    /**
     * Configures the URL codec for encoding and decoding URLs. Default is the `AngularJSCodec`
     */
    urlCodec?: typeof UrlCodec;
    /**
     * Configures the base href when used in server-side rendered applications
     */
    serverBaseHref?: string;
    /**
     * Configures the base href when used in client-side rendered applications
     */
    appBaseHref?: string;
}

/**
 * `NgModule` used for providing and configuring Angular's Unified Location Service for upgrading.
 *
 * @see [Using the Unified Angular Location Service](guide/upgrade#using-the-unified-angular-location-service)
 *
 * @publicApi
 */
export declare class LocationUpgradeModule {
    static config(config?: LocationUpgradeConfig): ModuleWithProviders<LocationUpgradeModule>;
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<LocationUpgradeModule, never, [typeof ɵngcc1.CommonModule], never>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<LocationUpgradeModule>;
}


/**
 * A codec for encoding and decoding URL parts.
 *
 * @publicApi
 **/
export declare abstract class UrlCodec {
    /**
     * Encodes the path from the provided string
     *
     * @param path The path string
     */
    abstract encodePath(path: string): string;
    /**
     * Decodes the path from the provided string
     *
     * @param path The path string
     */
    abstract decodePath(path: string): string;
    /**
     * Encodes the search string from the provided string or object
     *
     * @param path The path string or object
     */
    abstract encodeSearch(search: string | {
        [k: string]: unknown;
    }): string;
    /**
     * Decodes the search objects from the provided string
     *
     * @param path The path string
     */
    abstract decodeSearch(search: string): {
        [k: string]: unknown;
    };
    /**
     * Encodes the hash from the provided string
     *
     * @param path The hash string
     */
    abstract encodeHash(hash: string): string;
    /**
     * Decodes the hash from the provided string
     *
     * @param path The hash string
     */
    abstract decodeHash(hash: string): string;
    /**
     * Normalizes the URL from the provided string
     *
     * @param path The URL string
     */
    abstract normalize(href: string): string;
    /**
     * Normalizes the URL from the provided string, search, hash, and base URL parameters
     *
     * @param path The URL path
     * @param search The search object
     * @param hash The has string
     * @param baseUrl The base URL for the URL
     */
    abstract normalize(path: string, search: {
        [k: string]: unknown;
    }, hash: string, baseUrl?: string): string;
    /**
     * Checks whether the two strings are equal
     * @param valA First string for comparison
     * @param valB Second string for comparison
     */
    abstract areEqual(valA: string, valB: string): boolean;
    /**
     * Parses the URL string based on the base URL
     *
     * @param url The full URL string
     * @param base The base for the URL
     */
    abstract parse(url: string, base?: string): {
        href: string;
        protocol: string;
        host: string;
        search: string;
        hash: string;
        hostname: string;
        port: string;
        pathname: string;
    };
}

export declare function ɵangular_packages_common_upgrade_upgrade_a(config: LocationUpgradeConfig, appBaseHref?: string): string;

export declare function ɵangular_packages_common_upgrade_upgrade_b(config: LocationUpgradeConfig): any;

export declare function ɵangular_packages_common_upgrade_upgrade_c(platformLocation: PlatformLocation, baseHref: string, options?: LocationUpgradeConfig): HashLocationStrategy | PathLocationStrategy;

export declare function ɵangular_packages_common_upgrade_upgrade_d(ngUpgrade: UpgradeModule, location: Location, platformLocation: PlatformLocation, urlCodec: UrlCodec, locationStrategy: LocationStrategy): $locationShim;

export { }

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBncmFkZS5kLnRzIiwic291cmNlcyI6WyJ1cGdyYWRlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHY5LjEuMTJcbiAqIChjKSAyMDEwLTIwMjAgR29vZ2xlIExMQy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cblxuaW1wb3J0IHsgSGFzaExvY2F0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IExvY2F0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBNb2R1bGVXaXRoUHJvdmlkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFBhdGhMb2NhdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgUGxhdGZvcm1Mb2NhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IFVwZ3JhZGVNb2R1bGUgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XHJcblxyXG4vKipcclxuICogTG9jYXRpb24gc2VydmljZSB0aGF0IHByb3ZpZGVzIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgdGhlICRsb2NhdGlvbiBzZXJ2aWNlXHJcbiAqIHByb3ZpZGVkIGluIEFuZ3VsYXJKUy5cclxuICpcclxuICogQHNlZSBbVXNpbmcgdGhlIEFuZ3VsYXIgVW5pZmllZCBMb2NhdGlvbiBTZXJ2aWNlXShndWlkZS91cGdyYWRlI3VzaW5nLXRoZS11bmlmaWVkLWFuZ3VsYXItbG9jYXRpb24tc2VydmljZSlcclxuICpcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgJGxvY2F0aW9uU2hpbSB7XHJcbiAgICBwcml2YXRlIGxvY2F0aW9uO1xyXG4gICAgcHJpdmF0ZSBwbGF0Zm9ybUxvY2F0aW9uO1xyXG4gICAgcHJpdmF0ZSB1cmxDb2RlYztcclxuICAgIHByaXZhdGUgbG9jYXRpb25TdHJhdGVneTtcclxuICAgIHByaXZhdGUgaW5pdGFsaXppbmc7XHJcbiAgICBwcml2YXRlIHVwZGF0ZUJyb3dzZXI7XHJcbiAgICBwcml2YXRlICQkYWJzVXJsO1xyXG4gICAgcHJpdmF0ZSAkJHVybDtcclxuICAgIHByaXZhdGUgJCRwcm90b2NvbDtcclxuICAgIHByaXZhdGUgJCRob3N0O1xyXG4gICAgcHJpdmF0ZSAkJHBvcnQ7XHJcbiAgICBwcml2YXRlICQkcmVwbGFjZTtcclxuICAgIHByaXZhdGUgJCRwYXRoO1xyXG4gICAgcHJpdmF0ZSAkJHNlYXJjaDtcclxuICAgIHByaXZhdGUgJCRoYXNoO1xyXG4gICAgcHJpdmF0ZSAkJHN0YXRlO1xyXG4gICAgcHJpdmF0ZSAkJGNoYW5nZUxpc3RlbmVycztcclxuICAgIHByaXZhdGUgY2FjaGVkU3RhdGU7XHJcbiAgICBwcml2YXRlIHVybENoYW5nZXM7XHJcbiAgICBjb25zdHJ1Y3RvcigkaW5qZWN0b3I6IGFueSwgbG9jYXRpb246IExvY2F0aW9uLCBwbGF0Zm9ybUxvY2F0aW9uOiBQbGF0Zm9ybUxvY2F0aW9uLCB1cmxDb2RlYzogVXJsQ29kZWMsIGxvY2F0aW9uU3RyYXRlZ3k6IExvY2F0aW9uU3RyYXRlZ3kpO1xyXG4gICAgcHJpdmF0ZSBpbml0aWFsaXplO1xyXG4gICAgcHJpdmF0ZSByZXNldEJyb3dzZXJVcGRhdGU7XHJcbiAgICBwcml2YXRlIGxhc3RIaXN0b3J5U3RhdGU7XHJcbiAgICBwcml2YXRlIGxhc3RCcm93c2VyVXJsO1xyXG4gICAgcHJpdmF0ZSBicm93c2VyVXJsO1xyXG4gICAgcHJpdmF0ZSBsYXN0Q2FjaGVkU3RhdGU7XHJcbiAgICBwcml2YXRlIGNhY2hlU3RhdGU7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gZW11bGF0ZXMgdGhlICRicm93c2VyLnN0YXRlKCkgZnVuY3Rpb24gZnJvbSBBbmd1bGFySlMuIEl0IHdpbGwgY2F1c2VcclxuICAgICAqIGhpc3Rvcnkuc3RhdGUgdG8gYmUgY2FjaGVkIHVubGVzcyBjaGFuZ2VkIHdpdGggZGVlcCBlcXVhbGl0eSBjaGVjay5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBicm93c2VyU3RhdGU7XHJcbiAgICBwcml2YXRlIHN0cmlwQmFzZVVybDtcclxuICAgIHByaXZhdGUgZ2V0U2VydmVyQmFzZTtcclxuICAgIHByaXZhdGUgcGFyc2VBcHBVcmw7XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVycyBsaXN0ZW5lcnMgZm9yIFVSTCBjaGFuZ2VzLiBUaGlzIEFQSSBpcyB1c2VkIHRvIGNhdGNoIHVwZGF0ZXMgcGVyZm9ybWVkIGJ5IHRoZVxyXG4gICAgICogQW5ndWxhckpTIGZyYW1ld29yay4gVGhlc2UgY2hhbmdlcyBhcmUgYSBzdWJzZXQgb2YgdGhlIGAkbG9jYXRpb25DaGFuZ2VTdGFydGAgYW5kXHJcbiAgICAgKiBgJGxvY2F0aW9uQ2hhbmdlU3VjY2Vzc2AgZXZlbnRzIHdoaWNoIGZpcmUgd2hlbiBBbmd1bGFySlMgdXBkYXRlcyBpdHMgaW50ZXJuYWxseS1yZWZlcmVuY2VkXHJcbiAgICAgKiB2ZXJzaW9uIG9mIHRoZSBicm93c2VyIFVSTC5cclxuICAgICAqXHJcbiAgICAgKiBJdCdzIHBvc3NpYmxlIGZvciBgJGxvY2F0aW9uQ2hhbmdlYCBldmVudHMgdG8gaGFwcGVuLCBidXQgZm9yIHRoZSBicm93c2VyIFVSTFxyXG4gICAgICogKHdpbmRvdy5sb2NhdGlvbikgdG8gcmVtYWluIHVuY2hhbmdlZC4gVGhpcyBgb25DaGFuZ2VgIGNhbGxiYWNrIHdpbGwgZmlyZSBvbmx5IHdoZW4gQW5ndWxhckpTXHJcbiAgICAgKiBhY3R1YWxseSB1cGRhdGVzIHRoZSBicm93c2VyIFVSTCAod2luZG93LmxvY2F0aW9uKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIGZvciB0aGUgbGlzdGVuZXIgd2hlbiB0aGUgVVJMIGNoYW5nZXMuXHJcbiAgICAgKiBAcGFyYW0gZXJyIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIGFuIGVycm9yIG9jY3Vycy5cclxuICAgICAqL1xyXG4gICAgb25DaGFuZ2UoZm46ICh1cmw6IHN0cmluZywgc3RhdGU6IHVua25vd24sIG9sZFVybDogc3RyaW5nLCBvbGRTdGF0ZTogdW5rbm93bikgPT4gdm9pZCwgZXJyPzogKGU6IEVycm9yKSA9PiB2b2lkKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHRoZSBwcm92aWRlZCBVUkwsIGFuZCBzZXRzIHRoZSBjdXJyZW50IFVSTCB0byB0aGUgcGFyc2VkIHJlc3VsdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICAkJHBhcnNlKHVybDogc3RyaW5nKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIHRoZSBwcm92aWRlZCBVUkwgYW5kIGl0cyByZWxhdGl2ZSBVUkwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVybCBUaGUgZnVsbCBVUkwgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHJlbEhyZWYgQSBVUkwgc3RyaW5nIHJlbGF0aXZlIHRvIHRoZSBmdWxsIFVSTCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgICQkcGFyc2VMaW5rVXJsKHVybDogc3RyaW5nLCByZWxIcmVmPzogc3RyaW5nIHwgbnVsbCk6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIHNldEJyb3dzZXJVcmxXaXRoRmFsbGJhY2s7XHJcbiAgICBwcml2YXRlIGNvbXBvc2VVcmxzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGZ1bGwgVVJMIHJlcHJlc2VudGF0aW9uIHdpdGggYWxsIHNlZ21lbnRzIGVuY29kZWQgYWNjb3JkaW5nIHRvXHJcbiAgICAgKiBydWxlcyBzcGVjaWZpZWQgaW5cclxuICAgICAqIFtSRkMgMzk4Nl0oaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzk4Ni50eHQpLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogLy8gZ2l2ZW4gVVJMIGh0dHA6Ly9leGFtcGxlLmNvbS8jL3NvbWUvcGF0aD9mb289YmFyJmJhej14b3hvXHJcbiAgICAgKiBsZXQgYWJzVXJsID0gJGxvY2F0aW9uLmFic1VybCgpO1xyXG4gICAgICogLy8gPT4gXCJodHRwOi8vZXhhbXBsZS5jb20vIy9zb21lL3BhdGg/Zm9vPWJhciZiYXo9eG94b1wiXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgYWJzVXJsKCk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IFVSTCwgb3Igc2V0cyBhIG5ldyBVUkwuIFdoZW4gc2V0dGluZyBhIFVSTCxcclxuICAgICAqIGNoYW5nZXMgdGhlIHBhdGgsIHNlYXJjaCwgYW5kIGhhc2gsIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0cyBvd24gaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIC8vIGdpdmVuIFVSTCBodHRwOi8vZXhhbXBsZS5jb20vIy9zb21lL3BhdGg/Zm9vPWJhciZiYXo9eG94b1xyXG4gICAgICogbGV0IHVybCA9ICRsb2NhdGlvbi51cmwoKTtcclxuICAgICAqIC8vID0+IFwiL3NvbWUvcGF0aD9mb289YmFyJmJhej14b3hvXCJcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICB1cmwoKTogc3RyaW5nO1xyXG4gICAgdXJsKHVybDogc3RyaW5nKTogdGhpcztcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBwcm90b2NvbCBvZiB0aGUgY3VycmVudCBVUkwuXHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIC8vIGdpdmVuIFVSTCBodHRwOi8vZXhhbXBsZS5jb20vIy9zb21lL3BhdGg/Zm9vPWJhciZiYXo9eG94b1xyXG4gICAgICogbGV0IHByb3RvY29sID0gJGxvY2F0aW9uLnByb3RvY29sKCk7XHJcbiAgICAgKiAvLyA9PiBcImh0dHBcIlxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHByb3RvY29sKCk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBwcm90b2NvbCBvZiB0aGUgY3VycmVudCBVUkwuXHJcbiAgICAgKlxyXG4gICAgICogSW4gY29udHJhc3QgdG8gdGhlIG5vbi1Bbmd1bGFySlMgdmVyc2lvbiBgbG9jYXRpb24uaG9zdGAgd2hpY2ggcmV0dXJucyBgaG9zdG5hbWU6cG9ydGAsIHRoaXNcclxuICAgICAqIHJldHVybnMgdGhlIGBob3N0bmFtZWAgcG9ydGlvbiBvbmx5LlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogLy8gZ2l2ZW4gVVJMIGh0dHA6Ly9leGFtcGxlLmNvbS8jL3NvbWUvcGF0aD9mb289YmFyJmJhej14b3hvXHJcbiAgICAgKiBsZXQgaG9zdCA9ICRsb2NhdGlvbi5ob3N0KCk7XHJcbiAgICAgKiAvLyA9PiBcImV4YW1wbGUuY29tXCJcclxuICAgICAqXHJcbiAgICAgKiAvLyBnaXZlbiBVUkwgaHR0cDovL3VzZXI6cGFzc3dvcmRAZXhhbXBsZS5jb206ODA4MC8jL3NvbWUvcGF0aD9mb289YmFyJmJhej14b3hvXHJcbiAgICAgKiBob3N0ID0gJGxvY2F0aW9uLmhvc3QoKTtcclxuICAgICAqIC8vID0+IFwiZXhhbXBsZS5jb21cIlxyXG4gICAgICogaG9zdCA9IGxvY2F0aW9uLmhvc3Q7XHJcbiAgICAgKiAvLyA9PiBcImV4YW1wbGUuY29tOjgwODBcIlxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGhvc3QoKTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHBvcnQgb2YgdGhlIGN1cnJlbnQgVVJMLlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAvLyBnaXZlbiBVUkwgaHR0cDovL2V4YW1wbGUuY29tLyMvc29tZS9wYXRoP2Zvbz1iYXImYmF6PXhveG9cclxuICAgICAqIGxldCBwb3J0ID0gJGxvY2F0aW9uLnBvcnQoKTtcclxuICAgICAqIC8vID0+IDgwXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcG9ydCgpOiBudW1iZXIgfCBudWxsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgVVJMLCBvciBjaGFuZ2VzIHRoZSBwYXRoIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGl0cyBvd25cclxuICAgICAqIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIFBhdGhzIHNob3VsZCBhbHdheXMgYmVnaW4gd2l0aCBmb3J3YXJkIHNsYXNoICgvKS4gVGhpcyBtZXRob2QgYWRkcyB0aGUgZm9yd2FyZCBzbGFzaFxyXG4gICAgICogaWYgaXQgaXMgbWlzc2luZy5cclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogLy8gZ2l2ZW4gVVJMIGh0dHA6Ly9leGFtcGxlLmNvbS8jL3NvbWUvcGF0aD9mb289YmFyJmJhej14b3hvXHJcbiAgICAgKiBsZXQgcGF0aCA9ICRsb2NhdGlvbi5wYXRoKCk7XHJcbiAgICAgKiAvLyA9PiBcIi9zb21lL3BhdGhcIlxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHBhdGgoKTogc3RyaW5nO1xyXG4gICAgcGF0aChwYXRoOiBzdHJpbmcgfCBudW1iZXIgfCBudWxsKTogdGhpcztcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGEgbWFwIG9mIHRoZSBzZWFyY2ggcGFyYW1ldGVycyBvZiB0aGUgY3VycmVudCBVUkwsIG9yIGNoYW5nZXMgYSBzZWFyY2hcclxuICAgICAqIHBhcnQgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzIG93biBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIC8vIGdpdmVuIFVSTCBodHRwOi8vZXhhbXBsZS5jb20vIy9zb21lL3BhdGg/Zm9vPWJhciZiYXo9eG94b1xyXG4gICAgICogbGV0IHNlYXJjaE9iamVjdCA9ICRsb2NhdGlvbi5zZWFyY2goKTtcclxuICAgICAqIC8vID0+IHtmb286ICdiYXInLCBiYXo6ICd4b3hvJ31cclxuICAgICAqXHJcbiAgICAgKiAvLyBzZXQgZm9vIHRvICd5aXBlZSdcclxuICAgICAqICRsb2NhdGlvbi5zZWFyY2goJ2ZvbycsICd5aXBlZScpO1xyXG4gICAgICogLy8gJGxvY2F0aW9uLnNlYXJjaCgpID0+IHtmb286ICd5aXBlZScsIGJhejogJ3hveG8nfVxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmc+fE9iamVjdC48QXJyYXkuPHN0cmluZz4+fSBzZWFyY2ggTmV3IHNlYXJjaCBwYXJhbXMgLSBzdHJpbmcgb3JcclxuICAgICAqIGhhc2ggb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIFdoZW4gY2FsbGVkIHdpdGggYSBzaW5nbGUgYXJndW1lbnQgdGhlIG1ldGhvZCBhY3RzIGFzIGEgc2V0dGVyLCBzZXR0aW5nIHRoZSBgc2VhcmNoYCBjb21wb25lbnRcclxuICAgICAqIG9mIGAkbG9jYXRpb25gIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogSWYgdGhlIGFyZ3VtZW50IGlzIGEgaGFzaCBvYmplY3QgY29udGFpbmluZyBhbiBhcnJheSBvZiB2YWx1ZXMsIHRoZXNlIHZhbHVlcyB3aWxsIGJlIGVuY29kZWRcclxuICAgICAqIGFzIGR1cGxpY2F0ZSBzZWFyY2ggcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xOdW1iZXJ8QXJyYXk8c3RyaW5nPnxib29sZWFuKT19IHBhcmFtVmFsdWUgSWYgYHNlYXJjaGAgaXMgYSBzdHJpbmcgb3IgbnVtYmVyLFxyXG4gICAgICogICAgIHRoZW4gYHBhcmFtVmFsdWVgXHJcbiAgICAgKiB3aWxsIG92ZXJyaWRlIG9ubHkgYSBzaW5nbGUgc2VhcmNoIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIElmIGBwYXJhbVZhbHVlYCBpcyBhbiBhcnJheSwgaXQgd2lsbCBvdmVycmlkZSB0aGUgcHJvcGVydHkgb2YgdGhlIGBzZWFyY2hgIGNvbXBvbmVudCBvZlxyXG4gICAgICogYCRsb2NhdGlvbmAgc3BlY2lmaWVkIHZpYSB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYHBhcmFtVmFsdWVgIGlzIGBudWxsYCwgdGhlIHByb3BlcnR5IHNwZWNpZmllZCB2aWEgdGhlIGZpcnN0IGFyZ3VtZW50IHdpbGwgYmUgZGVsZXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBJZiBgcGFyYW1WYWx1ZWAgaXMgYHRydWVgLCB0aGUgcHJvcGVydHkgc3BlY2lmaWVkIHZpYSB0aGUgZmlyc3QgYXJndW1lbnQgd2lsbCBiZSBhZGRlZCB3aXRoIG5vXHJcbiAgICAgKiB2YWx1ZSBub3IgdHJhaWxpbmcgZXF1YWwgc2lnbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwYXJzZWQgYHNlYXJjaGAgb2JqZWN0IG9mIHRoZSBjdXJyZW50IFVSTCwgb3IgdGhlIGNoYW5nZWQgYHNlYXJjaGAgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBzZWFyY2goKToge1xyXG4gICAgICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XHJcbiAgICB9O1xyXG4gICAgc2VhcmNoKHNlYXJjaDogc3RyaW5nIHwgbnVtYmVyIHwge1xyXG4gICAgICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XHJcbiAgICB9KTogdGhpcztcclxuICAgIHNlYXJjaChzZWFyY2g6IHN0cmluZyB8IG51bWJlciB8IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xyXG4gICAgfSwgcGFyYW1WYWx1ZTogbnVsbCB8IHVuZGVmaW5lZCB8IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmdbXSk6IHRoaXM7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBoYXNoIGZyYWdtZW50LCBvciBjaGFuZ2VzIHRoZSBoYXNoIGZyYWdtZW50IGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXHJcbiAgICAgKiBpdHMgb3duIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAvLyBnaXZlbiBVUkwgaHR0cDovL2V4YW1wbGUuY29tLyMvc29tZS9wYXRoP2Zvbz1iYXImYmF6PXhveG8jaGFzaFZhbHVlXHJcbiAgICAgKiBsZXQgaGFzaCA9ICRsb2NhdGlvbi5oYXNoKCk7XHJcbiAgICAgKiAvLyA9PiBcImhhc2hWYWx1ZVwiXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgaGFzaCgpOiBzdHJpbmc7XHJcbiAgICBoYXNoKGhhc2g6IHN0cmluZyB8IG51bWJlciB8IG51bGwpOiB0aGlzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRvIGAkbG9jYXRpb25gIGR1cmluZyB0aGUgY3VycmVudCBgJGRpZ2VzdGAgd2lsbCByZXBsYWNlIHRoZSBjdXJyZW50XHJcbiAgICAgKiBoaXN0b3J5IHJlY29yZCwgaW5zdGVhZCBvZiBhZGRpbmcgYSBuZXcgb25lLlxyXG4gICAgICovXHJcbiAgICByZXBsYWNlKCk6IHRoaXM7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgaGlzdG9yeSBzdGF0ZSBvYmplY3Qgd2hlbiBjYWxsZWQgd2l0aG91dCBhbnkgcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIENoYW5nZSB0aGUgaGlzdG9yeSBzdGF0ZSBvYmplY3Qgd2hlbiBjYWxsZWQgd2l0aCBvbmUgcGFyYW1ldGVyIGFuZCByZXR1cm4gYCRsb2NhdGlvbmAuXHJcbiAgICAgKiBUaGUgc3RhdGUgb2JqZWN0IGlzIGxhdGVyIHBhc3NlZCB0byBgcHVzaFN0YXRlYCBvciBgcmVwbGFjZVN0YXRlYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzdXBwb3J0ZWQgb25seSBpbiBIVE1MNSBtb2RlIGFuZCBvbmx5IGluIGJyb3dzZXJzIHN1cHBvcnRpbmdcclxuICAgICAqIHRoZSBIVE1MNSBIaXN0b3J5IEFQSSBtZXRob2RzIHN1Y2ggYXMgYHB1c2hTdGF0ZWAgYW5kIGByZXBsYWNlU3RhdGVgLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0XHJcbiAgICAgKiBvbGRlciBicm93c2VycyAobGlrZSBJRTkgb3IgQW5kcm9pZCA8IDQuMCksIGRvbid0IHVzZSB0aGlzIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0YXRlKCk6IHVua25vd247XHJcbiAgICBzdGF0ZShzdGF0ZTogdW5rbm93bik6IHRoaXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgZmFjdG9yeSBmdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgYCRsb2NhdGlvblNoaW1gIGluIEFuZ3VsYXIsXHJcbiAqIGFuZCBwcm92aWRlcyBhbiBBUEktY29tcGF0aWFibGUgYCRsb2NhdGlvblByb3ZpZGVyYCBmb3IgQW5ndWxhckpTLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyAkbG9jYXRpb25TaGltUHJvdmlkZXIge1xyXG4gICAgcHJpdmF0ZSBuZ1VwZ3JhZGU7XHJcbiAgICBwcml2YXRlIGxvY2F0aW9uO1xyXG4gICAgcHJpdmF0ZSBwbGF0Zm9ybUxvY2F0aW9uO1xyXG4gICAgcHJpdmF0ZSB1cmxDb2RlYztcclxuICAgIHByaXZhdGUgbG9jYXRpb25TdHJhdGVneTtcclxuICAgIGNvbnN0cnVjdG9yKG5nVXBncmFkZTogVXBncmFkZU1vZHVsZSwgbG9jYXRpb246IExvY2F0aW9uLCBwbGF0Zm9ybUxvY2F0aW9uOiBQbGF0Zm9ybUxvY2F0aW9uLCB1cmxDb2RlYzogVXJsQ29kZWMsIGxvY2F0aW9uU3RyYXRlZ3k6IExvY2F0aW9uU3RyYXRlZ3kpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCB0aGF0IHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgdGhlICRsb2NhdGlvblNoaW1cclxuICAgICAqL1xyXG4gICAgJGdldCgpOiAkbG9jYXRpb25TaGltO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdHViIG1ldGhvZCB1c2VkIHRvIGtlZXAgQVBJIGNvbXBhdGlibGUgd2l0aCBBbmd1bGFySlMuIFRoaXMgc2V0dGluZyBpcyBjb25maWd1cmVkIHRocm91Z2hcclxuICAgICAqIHRoZSBMb2NhdGlvblVwZ3JhZGVNb2R1bGUncyBgY29uZmlnYCBtZXRob2QgaW4geW91ciBBbmd1bGFyIGFwcC5cclxuICAgICAqL1xyXG4gICAgaGFzaFByZWZpeChwcmVmaXg/OiBzdHJpbmcpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdHViIG1ldGhvZCB1c2VkIHRvIGtlZXAgQVBJIGNvbXBhdGlibGUgd2l0aCBBbmd1bGFySlMuIFRoaXMgc2V0dGluZyBpcyBjb25maWd1cmVkIHRocm91Z2hcclxuICAgICAqIHRoZSBMb2NhdGlvblVwZ3JhZGVNb2R1bGUncyBgY29uZmlnYCBtZXRob2QgaW4geW91ciBBbmd1bGFyIGFwcC5cclxuICAgICAqL1xyXG4gICAgaHRtbDVNb2RlKG1vZGU/OiBhbnkpOiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogQSBgVXJsQ29kZWNgIHRoYXQgdXNlcyBsb2dpYyBmcm9tIEFuZ3VsYXJKUyB0byBzZXJpYWxpemUgYW5kIHBhcnNlIFVSTHNcclxuICogYW5kIFVSTCBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBbmd1bGFySlNVcmxDb2RlYyBpbXBsZW1lbnRzIFVybENvZGVjIHtcclxuICAgIGVuY29kZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nO1xyXG4gICAgZW5jb2RlU2VhcmNoKHNlYXJjaDogc3RyaW5nIHwge1xyXG4gICAgICAgIFtrOiBzdHJpbmddOiB1bmtub3duO1xyXG4gICAgfSk6IHN0cmluZztcclxuICAgIGVuY29kZUhhc2goaGFzaDogc3RyaW5nKTogc3RyaW5nO1xyXG4gICAgZGVjb2RlUGF0aChwYXRoOiBzdHJpbmcsIGh0bWw1TW9kZT86IGJvb2xlYW4pOiBzdHJpbmc7XHJcbiAgICBkZWNvZGVTZWFyY2goc2VhcmNoOiBzdHJpbmcpOiB7XHJcbiAgICAgICAgW2s6IHN0cmluZ106IHVua25vd247XHJcbiAgICB9O1xyXG4gICAgZGVjb2RlSGFzaChoYXNoOiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICBub3JtYWxpemUoaHJlZjogc3RyaW5nKTogc3RyaW5nO1xyXG4gICAgbm9ybWFsaXplKHBhdGg6IHN0cmluZywgc2VhcmNoOiB7XHJcbiAgICAgICAgW2s6IHN0cmluZ106IHVua25vd247XHJcbiAgICB9LCBoYXNoOiBzdHJpbmcsIGJhc2VVcmw/OiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICBhcmVFcXVhbCh2YWxBOiBzdHJpbmcsIHZhbEI6IHN0cmluZyk6IGJvb2xlYW47XHJcbiAgICBwYXJzZSh1cmw6IHN0cmluZywgYmFzZT86IHN0cmluZyk6IHtcclxuICAgICAgICBocmVmOiBzdHJpbmc7XHJcbiAgICAgICAgcHJvdG9jb2w6IHN0cmluZztcclxuICAgICAgICBob3N0OiBzdHJpbmc7XHJcbiAgICAgICAgc2VhcmNoOiBzdHJpbmc7XHJcbiAgICAgICAgaGFzaDogc3RyaW5nO1xyXG4gICAgICAgIGhvc3RuYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgcG9ydDogc3RyaW5nO1xyXG4gICAgICAgIHBhdGhuYW1lOiBzdHJpbmc7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQSBwcm92aWRlciB0b2tlbiB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgbG9jYXRpb24gdXBncmFkZSBtb2R1bGUuXHJcbiAqXHJcbiAqIEBwdWJsaWNBcGlcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IExPQ0FUSU9OX1VQR1JBREVfQ09ORklHVVJBVElPTjogSW5qZWN0aW9uVG9rZW48TG9jYXRpb25VcGdyYWRlQ29uZmlnPjtcclxuXHJcbi8qKlxyXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIExvY2F0aW9uVXBncmFkZS5cclxuICpcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIExvY2F0aW9uVXBncmFkZUNvbmZpZyB7XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgd2hldGhlciB0aGUgbG9jYXRpb24gdXBncmFkZSBtb2R1bGUgc2hvdWxkIHVzZSB0aGUgYEhhc2hMb2NhdGlvblN0cmF0ZWd5YFxyXG4gICAgICogb3IgdGhlIGBQYXRoTG9jYXRpb25TdHJhdGVneWBcclxuICAgICAqL1xyXG4gICAgdXNlSGFzaD86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGhhc2ggcHJlZml4IHVzZWQgaW4gdGhlIFVSTCB3aGVuIHVzaW5nIHRoZSBgSGFzaExvY2F0aW9uU3RyYXRlZ3lgXHJcbiAgICAgKi9cclxuICAgIGhhc2hQcmVmaXg/OiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgdGhlIFVSTCBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIFVSTHMuIERlZmF1bHQgaXMgdGhlIGBBbmd1bGFySlNDb2RlY2BcclxuICAgICAqL1xyXG4gICAgdXJsQ29kZWM/OiB0eXBlb2YgVXJsQ29kZWM7XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGJhc2UgaHJlZiB3aGVuIHVzZWQgaW4gc2VydmVyLXNpZGUgcmVuZGVyZWQgYXBwbGljYXRpb25zXHJcbiAgICAgKi9cclxuICAgIHNlcnZlckJhc2VIcmVmPzogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIHRoZSBiYXNlIGhyZWYgd2hlbiB1c2VkIGluIGNsaWVudC1zaWRlIHJlbmRlcmVkIGFwcGxpY2F0aW9uc1xyXG4gICAgICovXHJcbiAgICBhcHBCYXNlSHJlZj86IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIGBOZ01vZHVsZWAgdXNlZCBmb3IgcHJvdmlkaW5nIGFuZCBjb25maWd1cmluZyBBbmd1bGFyJ3MgVW5pZmllZCBMb2NhdGlvbiBTZXJ2aWNlIGZvciB1cGdyYWRpbmcuXHJcbiAqXHJcbiAqIEBzZWUgW1VzaW5nIHRoZSBVbmlmaWVkIEFuZ3VsYXIgTG9jYXRpb24gU2VydmljZV0oZ3VpZGUvdXBncmFkZSN1c2luZy10aGUtdW5pZmllZC1hbmd1bGFyLWxvY2F0aW9uLXNlcnZpY2UpXHJcbiAqXHJcbiAqIEBwdWJsaWNBcGlcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIExvY2F0aW9uVXBncmFkZU1vZHVsZSB7XHJcbiAgICBzdGF0aWMgY29uZmlnKGNvbmZpZz86IExvY2F0aW9uVXBncmFkZUNvbmZpZyk6IE1vZHVsZVdpdGhQcm92aWRlcnM8TG9jYXRpb25VcGdyYWRlTW9kdWxlPjtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBBIGNvZGVjIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgVVJMIHBhcnRzLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqKi9cclxuZXhwb3J0IGRlY2xhcmUgYWJzdHJhY3QgY2xhc3MgVXJsQ29kZWMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoZSBwYXRoIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBlbmNvZGVQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyB0aGUgcGF0aCBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZGVjb2RlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhlIHNlYXJjaCBzdHJpbmcgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nIG9yIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHN0cmluZyBvciBvYmplY3RcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZW5jb2RlU2VhcmNoKHNlYXJjaDogc3RyaW5nIHwge1xyXG4gICAgICAgIFtrOiBzdHJpbmddOiB1bmtub3duO1xyXG4gICAgfSk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyB0aGUgc2VhcmNoIG9iamVjdHMgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGRlY29kZVNlYXJjaChzZWFyY2g6IHN0cmluZyk6IHtcclxuICAgICAgICBbazogc3RyaW5nXTogdW5rbm93bjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhlIGhhc2ggZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGhhc2ggc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGVuY29kZUhhc2goaGFzaDogc3RyaW5nKTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIHRoZSBoYXNoIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBoYXNoIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBkZWNvZGVIYXNoKGhhc2g6IHN0cmluZyk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyB0aGUgVVJMIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBVUkwgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IG5vcm1hbGl6ZShocmVmOiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIFVSTCBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmcsIHNlYXJjaCwgaGFzaCwgYW5kIGJhc2UgVVJMIHBhcmFtZXRlcnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgVVJMIHBhdGhcclxuICAgICAqIEBwYXJhbSBzZWFyY2ggVGhlIHNlYXJjaCBvYmplY3RcclxuICAgICAqIEBwYXJhbSBoYXNoIFRoZSBoYXMgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gYmFzZVVybCBUaGUgYmFzZSBVUkwgZm9yIHRoZSBVUkxcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgbm9ybWFsaXplKHBhdGg6IHN0cmluZywgc2VhcmNoOiB7XHJcbiAgICAgICAgW2s6IHN0cmluZ106IHVua25vd247XHJcbiAgICB9LCBoYXNoOiBzdHJpbmcsIGJhc2VVcmw/OiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB0d28gc3RyaW5ncyBhcmUgZXF1YWxcclxuICAgICAqIEBwYXJhbSB2YWxBIEZpcnN0IHN0cmluZyBmb3IgY29tcGFyaXNvblxyXG4gICAgICogQHBhcmFtIHZhbEIgU2Vjb25kIHN0cmluZyBmb3IgY29tcGFyaXNvblxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBhcmVFcXVhbCh2YWxBOiBzdHJpbmcsIHZhbEI6IHN0cmluZyk6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyB0aGUgVVJMIHN0cmluZyBiYXNlZCBvbiB0aGUgYmFzZSBVUkxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBmdWxsIFVSTCBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBiYXNlIFRoZSBiYXNlIGZvciB0aGUgVVJMXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHBhcnNlKHVybDogc3RyaW5nLCBiYXNlPzogc3RyaW5nKToge1xyXG4gICAgICAgIGhyZWY6IHN0cmluZztcclxuICAgICAgICBwcm90b2NvbDogc3RyaW5nO1xyXG4gICAgICAgIGhvc3Q6IHN0cmluZztcclxuICAgICAgICBzZWFyY2g6IHN0cmluZztcclxuICAgICAgICBoYXNoOiBzdHJpbmc7XHJcbiAgICAgICAgaG9zdG5hbWU6IHN0cmluZztcclxuICAgICAgICBwb3J0OiBzdHJpbmc7XHJcbiAgICAgICAgcGF0aG5hbWU6IHN0cmluZztcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIMm1YW5ndWxhcl9wYWNrYWdlc19jb21tb25fdXBncmFkZV91cGdyYWRlX2EoY29uZmlnOiBMb2NhdGlvblVwZ3JhZGVDb25maWcsIGFwcEJhc2VIcmVmPzogc3RyaW5nKTogc3RyaW5nO1xyXG5cclxuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gybVhbmd1bGFyX3BhY2thZ2VzX2NvbW1vbl91cGdyYWRlX3VwZ3JhZGVfYihjb25maWc6IExvY2F0aW9uVXBncmFkZUNvbmZpZyk6IGFueTtcclxuXHJcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIMm1YW5ndWxhcl9wYWNrYWdlc19jb21tb25fdXBncmFkZV91cGdyYWRlX2MocGxhdGZvcm1Mb2NhdGlvbjogUGxhdGZvcm1Mb2NhdGlvbiwgYmFzZUhyZWY6IHN0cmluZywgb3B0aW9ucz86IExvY2F0aW9uVXBncmFkZUNvbmZpZyk6IEhhc2hMb2NhdGlvblN0cmF0ZWd5IHwgUGF0aExvY2F0aW9uU3RyYXRlZ3k7XHJcblxyXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiDJtWFuZ3VsYXJfcGFja2FnZXNfY29tbW9uX3VwZ3JhZGVfdXBncmFkZV9kKG5nVXBncmFkZTogVXBncmFkZU1vZHVsZSwgbG9jYXRpb246IExvY2F0aW9uLCBwbGF0Zm9ybUxvY2F0aW9uOiBQbGF0Zm9ybUxvY2F0aW9uLCB1cmxDb2RlYzogVXJsQ29kZWMsIGxvY2F0aW9uU3RyYXRlZ3k6IExvY2F0aW9uU3RyYXRlZ3kpOiAkbG9jYXRpb25TaGltO1xyXG5cclxuZXhwb3J0IHsgfVxyXG4iXX0=